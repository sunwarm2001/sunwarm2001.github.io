{"meta":{"title":"sunwarm","subtitle":null,"description":null,"author":"sunwarm2001","url":"https://sunwarm2001.github.io","root":"/"},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-11-05T05:15:24.316Z","comments":false,"path":"client/index.html","permalink":"https://sunwarm2001.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-11-05T05:15:24.316Z","comments":false,"path":"bangumi/index.html","permalink":"https://sunwarm2001.github.io/bangumi/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-11-05T05:15:24.314Z","comments":false,"path":"about/index.html","permalink":"https://sunwarm2001.github.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"comment","date":"2020-11-07T09:01:10.000Z","updated":"2021-01-04T03:27:40.487Z","comments":true,"path":"comment/index.html","permalink":"https://sunwarm2001.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-11-05T05:15:24.326Z","comments":false,"path":"lab/index.html","permalink":"https://sunwarm2001.github.io/lab/index.html","excerpt":"","text":"sakura主题 balabala"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-11-05T05:15:24.316Z","comments":false,"path":"donate/index.html","permalink":"https://sunwarm2001.github.io/donate/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2022-08-26T03:57:44.270Z","comments":true,"path":"links/index.html","permalink":"https://sunwarm2001.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-06T08:15:57.000Z","updated":"2020-11-07T10:15:55.577Z","comments":false,"path":"tags/index.html","permalink":"https://sunwarm2001.github.io/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2020-11-07T08:41:04.000Z","updated":"2022-08-25T14:04:58.238Z","comments":false,"path":"music/index.html","permalink":"https://sunwarm2001.github.io/music/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-11-05T05:15:24.333Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://sunwarm2001.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-11-05T05:15:24.333Z","comments":true,"path":"rss/index.html","permalink":"https://sunwarm2001.github.io/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-11-05T05:15:24.333Z","comments":false,"path":"video/index.html","permalink":"https://sunwarm2001.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"","slug":"Linux定时运行Python脚本","date":"2023-02-24T10:44:19.965Z","updated":"2023-02-24T10:44:19.965Z","comments":true,"path":"2023/02/24/Linux定时运行Python脚本/","link":"","permalink":"https://sunwarm2001.github.io/2023/02/24/Linux%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8CPython%E8%84%9A%E6%9C%AC/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"git上传GitHub拒绝连接","slug":"git上传GitHub拒绝连接","date":"2023-01-11T09:18:00.000Z","updated":"2023-01-11T09:33:21.960Z","comments":true,"path":"2023/01/11/git上传GitHub拒绝连接/","link":"","permalink":"https://sunwarm2001.github.io/2023/01/11/git%E4%B8%8A%E4%BC%A0GitHub%E6%8B%92%E7%BB%9D%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"background 在使用pycharm将自己修改之后的第二版代码上传到GitHub时，结果竟然报错如下，但是之前明明git push没有任何问题 分析问题 ssh: connect to host github.com port 22: Connection refused这个错误提示的是连接github.com的22端口被拒绝了。 原本以为http://github.com挂了，但是浏览器访问http://github.com一切正常。 在试过网上各种解决方案但都没用。这时偶然看到一个知乎大佬的文章才解决了。下面对其进行总结： 解决步骤： 1、使用ssh -vT git@github.com查看在建立ssh连接中的详细日志 $ ssh -vT git@github.com OpenSSH_9.0p1, OpenSSL 1.1.1o 3 May 2022 debug1: Reading configuration data /etc/ssh/ssh_config debug1: Connecting to github.com [::1] port 22. debug1: connect to address ::1 port 22: Connection refused debug1: Connecting to github.com [127.0.0.1] port 22. debug1: connect to address 127.0.0.1 port 22: Connection refused ssh: connect to host github.com port 22: Connection refused 连接http://github.com的地址居然是::1和127.0.0.1。前者是IPV6的localhost地址，后者是IPV4的localhost地址。 此时问题很明确——DNS解析出问题，导致http://github.com域名被解析成了localhost的ip地址，就自然连不上GitHub了。 2、在C:\\Windows\\System32\\drivers\\etc中找到文件hosts，添加GitHub的域名映射： 140.82.113.4 github.com 如何找到Github的域名映射 到 ipaddress 输入 github.com 查找到其IP地址 如何修改hosts文件 将hosts以txt方式打开，修改之后保存到桌面 将桌面的hosts.txt删除文件后缀 将桌面的hosts文件移动到原来hosts所在的文件夹中进行覆盖 修改完上述之后，重新在pycharm中进行push，成功将代码上传到GitHub。 参考文章： 知乎大佬的文章——坑：ssh: connect to host github.com port 22: Connection refused windows系统如何修改hosts？","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://sunwarm2001.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"git","slug":"git","permalink":"https://sunwarm2001.github.io/tags/git/"}],"author":"sunwarm"},{"title":"linux服务器常用命令","slug":"pytorch常用命令","date":"2022-12-19T16:29:28.000Z","updated":"2023-02-24T12:28:01.811Z","comments":true,"path":"2022/12/20/pytorch常用命令/","link":"","permalink":"https://sunwarm2001.github.io/2022/12/20/pytorch%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1、虚拟环境相关命令 新建一个新的环境，克隆原环境 conda create --name &lt;NewName&gt; --clone &lt;OldName&gt; 删除环境 conda remove --name &lt;Name&gt; --all 激活/退出环境 conda/source activate &lt;Name&gt; (Win/Linux) conda/source deactivate &lt;NowName&gt; 更新当前环境的python版本 conda install python=&lt;版本&gt; 查看pytorch版本号 &gt;&gt;&gt;python &gt;&gt;&gt;import torch &gt;&gt;&gt;torch.__version__ //注意version前后是两个下划线 &gt;&gt;&gt;exit() 查看 # 查看所有的虚拟环境 conda info -e # 查看当前环境下的所有包 conda list # 查看某个环境的所有包 conda list -n &lt;Name&gt; requirement.txt文件 or yml文件的安装虚拟环境 requirements.txt文件安装环境包，需要自己提前重新创建好一个新的环境，指定python的版本，环境的名称等等 而使用.yml文件则不用，因为.yml文件中会包含复制环境安装包时候对应的环境名，写在文件中 # requirement.txt文件下载 conda create -n &lt;your_env_name&gt; python=&lt;x.x&gt; #创建环境 source activate &lt;your_env_name&gt; #进入环境 pip install -r requirements.txt #下载包 # pip国内源 pip3 install scipy -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ # requirement.yml文件下载 # 直接下载yml文件中的包，名字在文件里也设置好了 conda env create -f &lt;FileName&gt;.yml conda env update -f environment.yml # 自定义虚拟环境，下载yml文件中的包 conda env create -f &lt;FileName&gt;.yml -n &lt;new_env_name&gt; conda env update -f &lt;FileName&gt;.yml -n &lt;env_name&gt; # 需要提前配置conda镜像源 详细教程见“pytorch问题集合——anaconda默认镜像源访问过慢” yml文件结构（部分代码如下） 标准yml文件结构示例 name: picie channels: - pytorch - anaconda - defaults dependencies: - _libgcc_mutex=0.1=main - backcall=0.2.0=py_0 - blas=1.0=mkl - python=3.7.7=hcff3b4d_5 - python-dateutil=2.8.1=py_0 - pytorch=1.2.0=py3.7_cuda10.0.130_cudnn7.6.2_0 - readline=8.0=h7b6447c_0 - scikit-learn=0.22.1=py37hd81dba3_0 - scipy=1.4.1=py37h0b6359f_0 - setuptools=47.3.0=py37_0 - six=1.15.0=py_0 - pip: - cycler==0.10.0 - cython==0.29.20 - kiwisolver==1.2.0 - matplotlib==3.3.0 - pyparsing==2.4.7 prefix: /scratch/cluster/jc88964/anaconda3/envs/picie name：是创建的虚拟环境名 channels：通道，即设置安装包的镜像源 dependents、pip：需要下载的包名 prefix则是自己anaconda文件下虚拟环境的路径（没用） 个人遇到的坑 channels是设置下载包使用的镜像源，但有时候使用的&quot;pytorch&quot;、&quot;anaconda&quot;通道会很卡，因此可以直接把该代码块**（前提是有设置过默认的国内镜像源）**conda创建环境卡在Solving Environment解决方法 dependencies中的python=3.7.7=hcff3b4d_5第二个=号是按照windows机器上的硬件或者软件进行配置的。在服务器上下载要删掉 ResolvePackageNotFound错误解决方法 实在是有些比较大的包（如pytorch）因为网络问题等原因下载不下来，从而导致整个虚拟环境安装崩溃。 解决方法：可以将比较大的包注释掉，将小包下载下来成功创建虚拟环境后，再下载大包 yml下载虚拟环境问题总结 用yml文件进行conda迁移环境时的报错小结 conda 安装yml环境中的各种坑 服务器调度命令 在服务器上，有多个节点，每个节点有多张GPU卡，但有时候人们sbatch任务的时候，经常会提交到同一张GPU卡上，而同节点的另张GPU卡却空缺，造成有资源却没充分利用，并且还因抢占同张GPU卡而运行速度慢。 ssh node08 # 连接到08号节点 nvidia-smi # 查看GPU使用情况（如下图） ps -ef|grep 422891 #根据PID查看具体使用者等信息 有了以上查看服务器资源调度情况后，我们可以将程序部署到空闲的GPU卡上（特别适用于debug）。添加以下几行语句即可部署到指定GPU上 #!/bin/bash #SBATCH --job-name dcd # 作业名 #SBATCH --partition compute #SBATCH --nodes 1 #SBATCH --gres=gpu:0 #SBATCH --nodelist=node02 #指定node节点 #SBATCH --cpus-per-task=4 #SBATCH --mem 8G #SBATCH --output runs/RainyW_%J.log # 保存输出结果 echo Start slurm job at `date` # running module load anaconda/3 module load cuda/10.2 module load cudnn/8.0.4-cuda10.2 source activate DCD-GAN-ORIGIN #python train.py --dataroot ./datasets CUDA_VISIBLE_DEVICES=0 python train.py --dataroot /public/home/yangmx/datasets/ICME_GC --name RainyW --model dcd --display_id 0 echo End slurm job at `date` 查看根目录下各文件夹占用大小 du -h --max-depth=0 dm #查看dm目录大小 du -h --max-depth=1 dm #查看dm目录大小，以及dm各文件文件夹的大小 du -h --max-depth=0 #查看当前文件夹大小 #如下图，查看checkpoints文件夹下各目录占用大小","categories":[{"name":"阅读","slug":"阅读","permalink":"https://sunwarm2001.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://sunwarm2001.github.io/tags/pytorch/"},{"name":"服务器","slug":"服务器","permalink":"https://sunwarm2001.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"author":"sunwarm"},{"title":"IDM从Google Drive快速下载超大型文件","slug":"IDM从Google Drive快速下载超大文件","date":"2022-12-19T15:48:58.000Z","updated":"2023-02-24T10:47:56.372Z","comments":true,"path":"2022/12/19/IDM从Google Drive快速下载超大文件/","link":"","permalink":"https://sunwarm2001.github.io/2022/12/19/IDM%E4%BB%8EGoogle%20Drive%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6/","excerpt":"","text":"Background 在深度学习中经常需要用到数据集，而一般作者通常会将数据集发布在Google Drive中，但是，Google Drive只会为每个下载链接保留一小时的有效期，即你会在Google Drive上的下载链接中会发现一个token字段，而这个字段的有效期是1小时。这一机制使得你必须在1小时内下载好你的文件，否则时机一到，token刷新，当前下载会话就会失效。如果无法有效实现断点续传的话，你就得从头下载了。 基于此，深受其扰的我只能求助互联网的大佬了，果真，被我发现了一款下载神器——IDM（Internet download mananger）。 1、IDM简介 IDM最牛逼的地方是其下载速度。一般的浏览器（如Google）只是单线程的下载，但是IDM能最大实现32线程的下载，使得很多单线程只能跑到每秒100kb/s的资源，IDM可以帮你加速到几十甚至上百兆每秒的下载速度。其功能有： 支持断点续传、具备批量下载和站点抓取功能 断点下载意味着中途若因外部因素而导致中断，又能够重新获取链接继续下载。 **自动嗅探”**网站中的媒体资源（视频、图片、文档等) 2、IDM下载 2.1下载并安装IDM 下载教程 注意：1、默认下载路径最好是C盘，否则容易出错 ​ 2、安装前关闭浏览器 ​ 3、既要下载该软件，又要在浏览器上下载插件 ​ 4、该软件只有一个月的试用期，之后是收费的 ​ 5、在下载前，要在选项 --&gt; 保存至，更改临时文件夹存放位置，不然临时文件会存放到C盘。 2.2 配置IDM 由于Google Drive是需要梯子进入，如果直接通过IDM下载是不行的。必须要对IDM设置代理才能成功下载，否则会不断的报错&quot;连接超时&quot;。 配置方法：在选项 --&gt; 代理服务器，更改为”使用系统设置“（前提是将vpn设置为全局代理） 2.3 成功下载 设置完上述后，开始从Google Drive中下载多达上百G的数据集了，次数IDM会自动抓取进行下载（如需关闭某类文件抓取，请设置）。以下便是成功运行的截图，可以看到这里我设置了最大16线程同时进行下载，传输速度最大能达到4MB/s，而普通的浏览器下载却是几百KB/s，大大加快了速度。 注意：下载过程中不要断开vpn哦，不然要重新捕获下载链接进行下载。 拓展阅读 IDM除了能下载文件夹外，还能下载许多网页的视频如b站，YouTube等，下载方法如下： 网站视频下载不了怎么办 除了IDM外，还有许多其他的方法对超大型文件快速下载。关注如下博客： 如何下载Google Drive中的超大型文件 除此之外，万能的GitHub能找到许多快速下载大型文件的方法，不要忘记它了噢！！！ Upated On 2.24 最近发现一个up主提供破解版的IDM。可以直接使用。https://www.bilibili.com/read/cv15185130/ 根据其他人使用反馈，有以下两个bug： 解压的文件夹是隐藏文件夹，需要设置才能看得见 管理员运行“!绿化.bat” 链接：https://pan.baidu.com/s/1jdvicCJLvxS0Ua-7fJQimQ?pwd=c7n6 提取码：c7n6","categories":[{"name":"技术","slug":"技术","permalink":"https://sunwarm2001.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IDM","slug":"IDM","permalink":"https://sunwarm2001.github.io/tags/IDM/"},{"name":"小妙招","slug":"小妙招","permalink":"https://sunwarm2001.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}],"author":"sunwarm"},{"title":"python语法基础","slug":"python基础","date":"2022-09-28T09:19:10.000Z","updated":"2022-12-19T15:45:19.885Z","comments":true,"path":"2022/09/28/python基础/","link":"","permalink":"https://sunwarm2001.github.io/2022/09/28/python%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1、浅拷贝与深拷贝 概念：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 对于可变对象（列表、字典、集合等） 赋值（b = a）：使b和a保持绝对的同步，当一方发生变化时（对象内的增删改，不创建新对象），另外一方也会发生同样的变化 浅拷贝c = a.copy()：最外一层是深拷贝，但是当a的某个元素是可变对象时，该元素是浅拷贝。即若： a = [1, 2, 3, [1, 2, 3]] c = a.copy() # 改变a[0~2]不会改变c[0~2]的值。。但是a[3]是一个列表（可变对象），与c[3]指向同一地址，改变a[3]会改变c[3] 深拷贝（d = deepcopy(a)）：d和a是完全独立的两个对象，a发生任何变化都不会影响 对于不可变对象（整型、字符串、元组等） 不管是赋值、浅拷贝还是深拷贝，当一方发生变化时，另外一方都完全不受影响 Python赋值、浅拷贝与深拷贝（附图解） 2、运算符 2.1 逻辑运算符 运算符 描述 实例 and 两个语句都为真，则返回 True。 a &gt; 3 and a &lt; 5 or 其中一个语句为真，则返回 True。 a &gt; 3 or a &lt; 4 not 反转结果，如果结果为 true，则返回 False not(a &gt; 3 and a &lt; 5) 2.2 身份运算符 身份运算符用于比较对象，不是比较它们是否相等，但如果它们实际上是同一个对象，则具有相同的内存位置： 运算符 描述 实例 is 如果两个变量是同一个对象，则返回 true。 x is y is not 如果两个变量不是同一个对象，则返回 true。 x is not y 2.2. 成员运算符 成员资格运算符用于测试子字符串是否在对象中出现： 运算符 描述 实例 in 如果对象中存在具有指定值的序列，则返回 True。 “123” in “123456” not in 如果对象中不存在具有指定值的序列，则返回 True。。 “123” not in “abcdef” 3、python集合 列表（List）：是有序且可更改的集合。允许重复的成员。list = [1, 2 ,3 ,4 , 5] 元组（Tuple）：是有序且不可更改的集合。允许重复的成员。tuple = (1, 2, 3, 4, 5) 集合（Set）：是一个无序和无索引的集合。没有重复的成员。set = {1, 2, 3, 4, 5} 词典（Dictionary）：是一个无序，可变和有索引的集合。没有重复的成员。dict = {“1”: “one”, “2”: “two”} 3.1 创建有一个项目的元组 如需创建仅包含一个项目的元组，必须在该项目后添加一个逗号，否则 Python 无法将变量识别为元组。`` thistuple = (\"apple\",) print(type(thistuple)) # tuple #不是元组 thistuple = (\"apple\") print(type(thistuple)) # str 3.2 set的访问 无法通过set_a[i]等索引方式来访问Set集合，因为set没有索引 3.3 dict的遍历（键值对） thisdict = &#123; \"one\": \"111\", \"two\": \"222\", \"three\": 333 &#125; # 返回的是键 for x in thisdict: print(x) # one two three # 返回的是值 for x in thisdict.values(): print(x) # 111 222 333 # 返回的是键值对 for x, y in thisdict.items(): print(x, y) # one 111 two 222 three 333 4、python的循化 4.1 while循化中的else语句 通过使用 else 语句，当循化条件不再成立时，会执行一次该代码块： i = 1 while i &lt; 6: i += 1 else: print(\"This is over\") # This is over 4.2 for循化中的else语句 for 循环中的 else 关键字指定循环结束时要执行的代码块 for x in range(10): pass else: print(\"Finally finished!\") # Finally finished! 5、python函数 5.1 函数作用域 如果在函数内部和外部创建具有相同名称的变量。在函数外部的变量是全局变量，而在函数内部的变量是局部变量，该变量只能在函数内使用且会覆盖全局变量。 x = 200 def test(): x = 100 print(x) test() # 100 print(x) # 200 global关键字：将在函数内部的局部变量变为全局变量。（此时在函数内部修改该变量会导致整个变量值改变，因为该变量已是全局变量） x = 200 def test(): global x x = 150 print(x) test() # 150 print(x) # 150 6、python类、 6.1 类变量与实例变量 类变量：类变量是公有变量，该类的所有实例都能共享。定义在类中，但在各个类方法外 实例变量：实例变量只作用于该实例。定义在任意类方法内部，以“self.变量名”的方式定义的变量 与java的联系：所谓的类变量就是静态变量，在java中以static修饰的。所谓的实例变量就是对象的成员变量，没有static修饰 class Person: country = \"CN\" //类变量 def __init__(self, name): self.name = name //实例变量 self.age = \"120岁以下\" //实例变量 if __name__ == \"__main__\": p = Person(15) print(p.country) print(p.name) print(p.age) class Person &#123; public int name;//成员变量，实例变量。随着对象的创建而存在于堆内存中 public String age; //成员变量，实例变量 public static String country = \"CN\";//静态的成员变量，类变量。随着类的加载而存在于方法区中 Person(int n)&#123; this.name = n; this.age = \"120岁以下\"; &#125; &#125; public class test &#123; public static void main(String[] args) &#123; Person p = new Person(15); System.out.println(p.name); System.out.println(p.country); &#125; &#125; 5.2 子类的继承 class Student(Person): pass 到目前为止，我们已经创建了一个子类Student，它继承了父类Person的属性和方法。 当在子类Student中添加 __init__() 函数时，子类将不再继承父类的 __init__() 函数。 原因：子类的__init__() 函数会覆盖对父类的__init__() 函数的继承 如需保持父类的__init__() 函数的继承，要添加对父类的 __init__() 函数的调用： class Student(Person): def __init__(self, name, age, adress) -&gt; None: super().__init__(name, age) self.adress = adress","categories":[{"name":"阅读","slug":"阅读","permalink":"https://sunwarm2001.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sunwarm2001.github.io/tags/python/"}],"author":"sunwarm"},{"title":"vscode云端环境","slug":"vscode云端环境搭建","date":"2022-09-14T01:44:46.000Z","updated":"2022-09-14T02:40:01.849Z","comments":true,"path":"2022/09/14/vscode云端环境搭建/","link":"","permalink":"https://sunwarm2001.github.io/2022/09/14/vscode%E4%BA%91%E7%AB%AF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"1、vscode部署云服务器开发 1.1 下载插件 在vscode插件中下载Remote-SSH 1.2 添加服务器连接配置 下载好插件后，点击左侧的选项卡配置，输入以下信息。之后信息会存放到 C:\\Users\\xxx\\.ssh\\config\\中 Host：自定义名称（随意填写） HostName：服务器ip地址 User：服务器用户名 1.3 连接服务器 在两处地方任意一个都可以连接到自己的远程服务器 打开之后弹出的小窗口就是远程服务器窗口，需要输入服务器密码进入。之后就可以在云服务器上开发，同时可以操作云服务器上的文件。 2、vscode上传文件到云服务器 说明：该插件仅支持将本地文件和服务器文件相互上传，或者仅对同名文件修改。不支持在对文件重命名或删除之后会自动更新，开发还是得在服务器上，不能在本地开发。 2.1 下载插件 在vscode插件中下载sftp 2.2 在vscode的工程中配置sftp.json 快捷键 ctrl+shift+P 打开指令窗口，输入sftp:config，回车，配置sftp.json文件。 只需更改host、username、remotePath属性。 &#123; &quot;name&quot;: &quot;My Server&quot;, #本地文件夹名称（可自定义） &quot;host&quot;: &quot;47.96.86.11&quot;, #服务器ip地址 &quot;protocol&quot;: &quot;sftp&quot;, #协议：默认为&quot;sftp&quot; &quot;port&quot;: 22, &quot;username&quot;: &quot;sunwarm2001&quot;, #服务器用户名 &quot;remotePath&quot;: &quot;/home/sunwarm2001&quot;, #上传到服务器的路径 &quot;uploadOnSave&quot;: true, #本地更新文件保存会自动同步到远程文件（不会同步重命名文件和删除文件） &quot;useTempFile&quot;: false, &quot;openSsh&quot;: false &#125; 2.3 上下传文件 右键文件，即可出现三个选项分别是：将本地文件上传到服务器；从服务器下载文件到本地；同时同步远程和本地 3、vscode上传配置和插件到GitHub 有时在原电脑上花大量时间配置了vscode，当更换一台电脑时，如何将之前的配置转移到现在的电脑上？ 注意：VSCode从1.48版本开始已经内置了同步功能，可以不用再使用Settings Sync插件了。 VSCode官方的配置同步方案","categories":[{"name":"插件配置","slug":"插件配置","permalink":"https://sunwarm2001.github.io/categories/%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://sunwarm2001.github.io/tags/vscode/"},{"name":"服务器","slug":"服务器","permalink":"https://sunwarm2001.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"插件","slug":"插件","permalink":"https://sunwarm2001.github.io/tags/%E6%8F%92%E4%BB%B6/"}],"author":"sunwarm"},{"title":"c盘清理","slug":"c盘清理","date":"2022-09-10T14:34:48.000Z","updated":"2022-09-14T02:40:21.085Z","comments":true,"path":"2022/09/10/c盘清理/","link":"","permalink":"https://sunwarm2001.github.io/2022/09/10/c%E7%9B%98%E6%B8%85%E7%90%86/","excerpt":"","text":"本人的c盘经常爆红，有时突然从十几G只剩下几个G了， 严重影响电脑性能。因此谨以此文来总结常见的清理c盘方法。 造成c盘空间不足的几个原因： 将应用软件安装到C盘中（如qq、微信等），此时系统会默认将应用产生的文件存储到c盘中。另外即使应用软件安装在D盘等其他磁盘中，在使用过程中也会在C盘中产生临时文件。（如腾讯视频） 电脑自动安装win10系统推出的更新补丁 开启电脑“休眠”虽然会加快电脑启动，但“休眠”会将内存数据全部保存到一个休眠文件HIBERFIL.SYS文件，通常有几个G大小 c盘清理方法 利用电脑管家（火绒）清理应用和系统产生的垃圾。并及时清理回收站（以上文件都会占用C盘空间） 右键磁盘选择&quot;磁盘清理&quot;，进一步可在其界面选择&quot;清理系统文件&quot; 关闭系统自动更新，有必要可以在&quot;设置&quot; --&gt; ”更新与安全“ --&gt; &quot;查看更新历史记录&quot;中卸载更新的补丁 （推荐） 以管理员运行cmd，输入指令powercfg -h off可关闭系统休眠，并删除休眠文件 HIBERFIL.SYS （未试过）以管理员运行cmd，输入以下指令删除临时文件： net stop wuauserv，按回车 net Stop cryptSvc，按回车 rd C:\\Windows\\SoftwareDistribution /s /q，按回车 rd C:\\Windows\\System32\\catroot2 /s /q ，按回车 net Start wuauserv，按回车 net start cryptSvc，按回车 或者备份好下面临时档案，然后shift+del强力删除 C:\\Windows\\Temp\\文件夹中的所有文件（系统临时文件） C:\\Windows\\Logs（日志文件） C:\\Windows\\Driver Cache（驱动程序的备份文件） C:\\Windows\\SoftwareDistribution\\download文件夹中的所有文件 C:\\Windows\\SoftwareDistribution下DataStore文件夹下的内容 C:\\Windows\\Prefetch文件夹中的所有文件（系统预读文件） C:\\Windows文件夹中以$开头和结尾的隐藏文件（安装系统补丁后的临时文件） C:\\Windows\\system32\\dllcache文件夹中的所有文件（动态链接库文件备份） C:\\User\\用户名\\Cookies\\文件夹中的所有文件（保留index文件） C:\\Users\\用户名\\AppData\\Local\\Temp文件夹中的所有文件（全部为用户临时文件） C:\\Users\\用户名\\AppData\\LocalLow\\Temp C:\\Users\\用户名\\AppData\\Local\\Microsoft\\Windows\\INetCache（Internet临时文件） C:\\Users\\用户名\\AppData\\Local\\Microsoft\\Windows\\History（上网的历史纪录） C:\\User\\用户名\\Recent\\文件夹中的所有文件（最近浏览和编辑过文件的快捷方式） C:\\$Recycle.Bin（回收站） 参考文章：清理c盘的方法","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://sunwarm2001.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://sunwarm2001.github.io/tags/%E9%98%85%E8%AF%BB/"},{"name":"c盘","slug":"c盘","permalink":"https://sunwarm2001.github.io/tags/c%E7%9B%98/"}],"author":"sunwarm"},{"title":"python问题合集","slug":"pytorch问题合集","date":"2022-09-09T08:18:33.000Z","updated":"2023-01-06T04:49:25.728Z","comments":true,"path":"2022/09/09/pytorch问题合集/","link":"","permalink":"https://sunwarm2001.github.io/2022/09/09/pytorch%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/","excerpt":"","text":"问题1：Torch not compiled with CUDA enabled 报错原因：电脑pytorch下载的是cpu版本，不是cuda版本 解决方法： 方法一：添加语句device = ('cuda' if torch.cuda.is_available() else 'cpu')，并将所有的.cuda()替换成to(device) 方法二：将torch.load(&quot;/home/model/model_J18.pth.tar&quot;)替换torch.load(&quot;C:/Users/user/Desktop/CoRRN/CoRRN/model/model_J18.pth.tar&quot;,map_location = 'cpu') 问题2：cv.imshow()数报错：error: (-215:Assertion failed) size.width&gt;0 &amp;&amp; size.height&gt;0 in function ‘cv::imshow’ 可能原因： 1、图像路径加载错误，比如“F:\\study\\lenmon.png”，此处需要使用双斜杠“F:\\\\study\\\\lenmon.png”，或者“F:/study/lenmon.png” 2、(关键点）OpenCV的图片路径不能使用中文路径，文件名也不能使用中文名 问题3：imshow()弹出窗口图片未响应；无法显示图片 解决方法：添加以下代码 cv2.imshow(&quot;Image&quot;,image) cv2.waitKey() cv2.destroyAllWindows() 服务器网络问题 报错提示：在服务器上跑代码，在执行到Downloading语句时出现以下两条Error报错语句 执行：Downloading https://ultralytics.com/assets/Arial.ttf to /public/home/yangmx/.config/Ultralytics/Arial.ttf... 报错：socket.gaierror: [Errno -2] Name or service not known urllib.error.URLError: &lt;urlopen error [Errno -2] Name or service not known&gt; 报错原因：服务器的网不行，下载Arial.ttf文件失败 解决方法： 点击该链接将文件Arial.ttf下载到本地，然后上传到服务器/public/home/yangmx/.config/Ultralytics/Arial.ttf下。重新跑代码即可。 纪念一下，今天一天运行两个项目，报的都是这种错，跑了十几遍还是这样，不管用不用外网也没用，晚上和师兄咨询了下才知道究其原因是服务器网的问题，只能自己手动下载 报错问题5：can’t conver cuda:0 device tensor to numpy. 报错原因： numpy不能读取CUDA tensor ，需要将它转化为 CPU tensor 解决办法：将报错代码self.numpy()改为self.cpu().numpy()即可 anaconda默认镜像源访问过慢 报错提示：CondaHTTPError: HTTP 000 CONNECTION FAILED for url https://repo.anaconda.com/pkgs/main/noarc 报错原因：anaconda默认镜像源访问速度过慢，会导致超时从而导致更新和下载失败。 解决方法：将默认镜像源更换为清华镜像源，并且删除默认镜像源。 情况1：服务器(终端)修改： 法1：在cmd终端中直接输入下列命令 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/free/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 法2：输入指令conda config命令从而生成.condarc文件，然后输入情况2的命令。 情况2：本地修改 找到.condarc文件（C盘–用户–用户名文件夹目录下）之后删除原来的内容，复制粘贴如下命令： channels: - defaults show_channel_urls: true default_channels: - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud show_channel_urls: true channels: - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ 其他bug解决方案： 1、没有.condarc文件：是因为没有在cmd命令中输入 conda config命令，只有第一次输入该命令之后，系统才会自动创建.condarc文件。（.condarc指的是运行期配置文件） 2、如果镜像源地址是 https开头，可以直接改成http即可。（因为https有时候会出现连接错误的问题，改成http后不会再出现此类问题。） 3、有的博客说删除.condarc文件的 -default配置行？ 防止google colab自动断开连接 说明：colab理论上最多可以连续工作12小时，这之后就会再重新分配资源，但这之中也会存在因为网络原因或者过久没有交互而导致的disconnect的情况，因此上述内容主要是为了解决这种问题的。但是如果训练的时间本身就是超过12小时所以断开了，那就不适用了 方法：在colab页面中，按F12，找到控制台，输入以下代码 function ConnectButton()&#123; console.log(&quot;Connect pushed&quot;); document.querySelector(&quot;#top-toolbar &gt; colab-connect-button&quot;).shadowRoot.querySelector(&quot;#connect&quot;).click() &#125; setInterval(ConnectButton,60000); //表示每60s自动点击一次，防止断开 执行了代码后，记下弹出的数字，那是intervalId，当想停止这段代码的执行时，只需要执行 clearInterval(intervalId) 就可以了，比如Id是340，那么就是clearInterval(340)。 AttributeError: ‘Namespace’ object has no attribute ‘beta2’ 有Namespace，说明是没有设置该参数 PyTorch Dataloader报错：ValueError: num_samples should be a positive integer value, but got num_samples=0 报错原因 (myown)第一种：文件夹没有数据集 第二种： self.train_dataloader = DataLoader(train_dataset, batch_size=TrainOption.train_batch_size, shuffle=TRUE, num_workers=TrainOption.data_load_worker_num) shuffle的参数设置错误导致，因为已经有batch_sample了，就不需要shuffle来进行随机的sample了，所以在这里的shuffle应该设置为FALSE才对。 第三种：未使用batch_sample，因此不是上述原因。经查发现，由于两系统下目录地址的格式不同，因此直接从windows移植过来的代码不能在指定目录下正常读取数据，且代码未设置sample读取个数为0时报错，导致dataset返回长度为0，小于batch_size，因此出现上述报错。 小tip：出现上述问题时，如未使用batch_sample，可首先检查dataset.len()是否正常。因多次出现上述问题，故记录。 AttributeError: module ‘torch’ has no attribute ‘rfft’ 报错信息 File &quot;/public/home/yangmx/code/DCD-GAN/models/dcd_model.py&quot;, line 279, in forward x_fft = torch.rfft(x, signal_ndim=2, normalized=False, onesided=True) AttributeError: module 'torch' has no attribute 'rfft' 报错原因：pytorch版本高了：pytorch旧版本（1.7之前）中有一个函数torch.rfft()，但是新版本（1.8、1.9）中被移除了，添加了torch.fft.rfft()， 解决办法 1、降低pytorch版本(conda可以，pip不行) 降低版本 conda install pytorch=1.8.0 -c soumith OR 卸载重装 conda unstall pytorch conda install pytorch = 版本 2、不太想换版本，因此在报错文件中添加以下代码，让新版本函数的输入输出和老版本一样，这下可以完美适配不同版本了 要添加的代码 try: from torch import irfft from torch import rfft except ImportError: from torch.fft import irfft2 from torch.fft import rfft2 def rfft(x, d): t = rfft2(x, dim = (-d)) return torch.stack((t.real, t.imag), -1) def irfft(x, d, signal_sizes): return irfft2(torch.complex(x[:,:,0], x[:,:,1]), s = signal_sizes, dim = (-d)) 原来代码 class FrequencyLoss(nn.Module): def __init__(self): super(FrequencyLoss, self).__init__() def forward(self, x, target): ... x_fft = torch.rfft(x, signal_ndim=2, normalized=False, onesided=True) target_fft = torch.rfft(target, signal_ndim=2, normalized=False, onesided=True) ... 更改之后的代码 try: from torch import irfft from torch import rfft except ImportError: from torch.fft import irfft2 from torch.fft import rfft2 def rfft(x, d): t = rfft2(x, dim = (-d)) return torch.stack((t.real, t.imag), -1) def irfft(x, d, signal_sizes): return irfft2(torch.complex(x[:,:,0], x[:,:,1]), s = signal_sizes, dim = (-d)) class FrequencyLoss(nn.Module): def __init__(self): super(FrequencyLoss, self).__init__() def forward(self, x, target): ... x_fft = torch.rfft(x, 2) target_fft = torch.rfft(target, 2) ... 旧版pytorch中torch.rfft和irfft在新版本中的对应","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://sunwarm2001.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sunwarm2001.github.io/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"https://sunwarm2001.github.io/tags/pytorch/"}],"author":"sunwarm"},{"title":"typora引用图床图片","slug":"hexo解决图床图片引用","date":"2022-08-26T08:50:46.000Z","updated":"2022-08-26T09:04:01.032Z","comments":true,"path":"2022/08/26/hexo解决图床图片引用/","link":"","permalink":"https://sunwarm2001.github.io/2022/08/26/hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8/","excerpt":"","text":"问题描述： 在用typora写文章时通常会将图片插入其中。本人利用PicGo将本地图片上传到gitee图床上以便外部访问。但是该图片在本地可以访问，而部署到hexo博客上时却失效。 解决方法： 笨方法：在每个文章的头部都添加：&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 一劳永逸：在layout/_partial/head.ejs文件中添加&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;。head.ejs文件会使生成的所有页面都带有该head。","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://sunwarm2001.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sunwarm2001.github.io/tags/hexo/"},{"name":"typora","slug":"typora","permalink":"https://sunwarm2001.github.io/tags/typora/"},{"name":"图床","slug":"图床","permalink":"https://sunwarm2001.github.io/tags/%E5%9B%BE%E5%BA%8A/"}],"author":"sunwarm"},{"title":"hexo自定义云标签","slug":"hexo自定义标签","date":"2022-08-26T07:46:47.000Z","updated":"2022-08-28T09:21:19.845Z","comments":true,"path":"2022/08/26/hexo自定义标签/","link":"","permalink":"https://sunwarm2001.github.io/2022/08/26/hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/","excerpt":"","text":"效果预览 1、自定义标签云 在该博客中，标签云的样式是参考cungudafa大佬的美化博客教程Hexo（sakura）自定义标签云 2、自定义分类 在该主题中，是将分类和标签云放到一起的，因此并没有在layout下单独创建新文件categories.ejs存放代码，而是把代码放到tags中。 在sakura/layout/tags文件下的id=content的div块中添加代码： &lt;!-- 自定义分类页 --&gt; &lt;main class=&quot;content&quot;&gt; &lt;%- partial('_widget/category-cloud') %&gt; &lt;% if (site.categories &amp;&amp; site.categories.length &gt; 0) %&gt; &lt;/main&gt; 在sakura/layout/_widget下新建文件：category-cloud.ejs &lt;% var colorArr = ['#F9EBEA', '#F5EEF8', '#D5F5E3', '#E8F8F5', '#FEF9E7', '#F8F9F9', '#82E0AA', '#D7BDE2', '#A3E4D7', '#85C1E9', '#F8C471', '#F9E79F', '#FFF']; var colorCount = colorArr.length; var hashCode = function (str) &#123; if (!str &amp;&amp; str.length === 0) &#123; return 0; &#125; var hash = 0; for (var i = 0, len = str.length; i &lt; len; i++) &#123; hash = ((hash &lt;&lt; 5) - hash) + str.charCodeAt(i); hash |= 0; &#125; return hash; &#125;; var i = 0; var isCategory = is_category(); %&gt; &lt;div id=&quot;category-cloud&quot; class=&quot;container chip-container&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;div class=&quot;tag-title center-align&quot;&gt; &lt;i class=&quot;fa fa-bookmark&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;文章分类 &lt;/div&gt; &lt;div class=&quot;tag-chips&quot;&gt; &lt;% if (site.categories &amp;&amp; site.categories.length &gt; 0) &#123; %&gt; &lt;% site.categories.map(function(category) &#123; %&gt; &lt;% i++; var color = i &gt;= colorCount ? colorArr[Math.abs(hashCode(category.name) % colorCount)] : colorArr[i - 1]; %&gt; &lt;a href=&quot;&lt;%- url_for(category.path) %&gt;&quot; title=&quot;&lt;%- category.name %&gt;: &lt;%- category.length %&gt;&quot;&gt; &lt;span class=&quot;chip center-align waves-effect waves-light &lt;% if (isCategory &amp;&amp; category.name == page.category) &#123; %&gt; chip-active &lt;% &#125; else &#123; %&gt; chip-default &lt;% &#125; %&gt;&quot; style=&quot;background-color: &lt;%- color %&gt;;&quot;&gt;&lt;%- category.name %&gt; &lt;span class=&quot;tag-length&quot;&gt;&lt;%- category.length %&gt;&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;% &#125;); %&gt; &lt;% &#125; else &#123; %&gt; &lt;%= __('categoryEmptyTip') %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 参考博客：Hexo-Sakura主题美化 拓展应用： 在layout/category.ejs文件末尾添加代码，即可在所有分类页面中显示云标签和分类页 &lt;div id=&quot;content&quot; class=&quot;site-content&quot;&gt; &lt;!-- 自定义云标签 --&gt; &lt;div id=&quot;main&quot;&gt; &lt;header class=&quot;page-header&quot;&gt; &lt;h1 class=&quot;cat-title&quot;&gt;标签云&lt;/h1&gt; &lt;span class=&quot;cat-des&quot;&gt; &lt;p&gt;&lt;%- &quot;Tags &quot; + site.tags.length %&gt;&lt;/p&gt; &lt;/span&gt; &lt;/header&gt; &lt;div id=&quot;main-part&quot;&gt; &lt;div class=&quot;tag-cloud&quot;&gt; &lt;div class=&quot;tag-cloud-title&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tag-cloud-tags&quot;&gt; &lt;%- tagcloud(&#123; min_font: 15, max_font: 30, amount: 200, color: true, start_color: '#ff6666', end_color: '#0099cc' &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 自定义分类页 --&gt; &lt;main class=&quot;content&quot;&gt; &lt;%- partial('_widget/category-cloud') %&gt; &lt;% if (site.categories &amp;&amp; site.categories.length &gt; 0) %&gt; &lt;/main&gt; &lt;/div&gt; 如在《技术》分类页面中显示，效果预览：","categories":[{"name":"插件配置","slug":"插件配置","permalink":"https://sunwarm2001.github.io/categories/%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sunwarm2001.github.io/tags/hexo/"},{"name":"美化","slug":"美化","permalink":"https://sunwarm2001.github.io/tags/%E7%BE%8E%E5%8C%96/"}],"author":"sunwarm"},{"title":"hexo + KaTex","slug":"hexo更换markdown渲染器&配置katex","date":"2022-08-25T10:13:35.000Z","updated":"2022-09-10T14:56:39.367Z","comments":true,"path":"2022/08/25/hexo更换markdown渲染器&配置katex/","link":"","permalink":"https://sunwarm2001.github.io/2022/08/25/hexo%E6%9B%B4%E6%8D%A2markdown%E6%B8%B2%E6%9F%93%E5%99%A8&%E9%85%8D%E7%BD%AEkatex/","excerpt":"","text":"markdown 常用渲染器 hexo-renderer-marked：hexo 默认的渲染器，不支持复杂的数学公式 hexo-renderer-kramed：支持复杂的数学公式，mathjax 的渲染方式 hexo-renderer-markdown-it：取代第一个的渲染器，渲染更快，更符合 CommonMark 规则。 hexo-renderer-markdown-it-katex：跟上一个差不多，但是不用设置就支持 katex hexo-renderer-markdown-it-plus：好用，可以自己决定是否要渲染 katex 公式。此外能渲染的东西多，但是已经不维护了。 @upupming/hexo-renderer-markdown-it-plus ：上一个的升级版。好用。支持的功能多。 安装 markdown 渲染器 说明：hexo 默认的 markdown 渲染器是 hexo-renderer-marked，但该渲染器不支持 LaTex 数学公式。因此该博客使用@upupming/hexo-renderer-markdown-it-plus插件 1、卸载原来的渲染器 npm uninstall hexo-renderer-marked --save 2、下载新渲染器 npm i @upupming/hexo-renderer-markdown-it-plus --save 配置 KaTex 用于数学公式 LaTex 1、在根目录的_config.yml 中添加： markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight 2、在 themes\\sakura_config.yml 中添加： # Math Equations Render Support math: enable: true per_page: false engine: katex katex: https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css 参考博客： hexo 更换 markdown 渲染器 插件官网文档 Hexo 和 KaTeX 遇到的问题： Hexo 使用 LaTeX 公式重复显示","categories":[{"name":"插件配置","slug":"插件配置","permalink":"https://sunwarm2001.github.io/categories/%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sunwarm2001.github.io/tags/hexo/"},{"name":"latex","slug":"latex","permalink":"https://sunwarm2001.github.io/tags/latex/"}],"author":"sunwarm"},{"title":"基础算法模板思路","slug":"基础算法思想","date":"2020-11-13T09:09:49.000Z","updated":"2022-09-10T14:56:29.076Z","comments":true,"path":"2020/11/13/基础算法思想/","link":"","permalink":"https://sunwarm2001.github.io/2020/11/13/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/","excerpt":"","text":"快速排序和归并排序 核心思想：分治 时间复杂度：O(nlogn) 快速排序——模板题 快速排序 思路 确定分界点：可以取q[l], q[r], q[(l+r)/2]中的任一个 调整区间：将区间分为两部分，使得左区间所有的数&lt;=x，右区间所有的数&gt;=x（左右区间长度不等） 递归处理左右区间 代码 void quick_sort(int q[],int l, int r) &#123; if(l&gt;=r) return; //递归出口 int x = q[l+r&gt;&gt;1], i = l-1, j = r+1; //注解 while(i &lt; j) &#123; do i++; while(q[i] &lt; x); do j--; while(q[j] &gt; x); if(i &lt; j) swap(q[i],q[j]); &#125; quick_sort(q,l,j); quick_sort(q,j+1,r); &#125; 注解 当递归函数是quick_sort(q,l,i-1); quick_sort(q,i,r);时，x不能取q[l]，否则会死循环； 当递归函数是quick_sort(q,l,j);quick_sort(q,j+1,r);时，x不能取q[r],否则会死循环； 综上所述：x最好取 q[l+r&gt;&gt;1]; 归并排序——模板题 归并排序 思路 确定分界点（取区间的中点） 递归排序左右两区间 归并（合二为一） 代码 const int N = 1000; int tmp[N]; //tmp：存放q数组中已排序的部分 void merge_sort(int q[], int l ,int r) &#123; //递归出口 if(l&gt;=r) return; int mid = l+r &gt;&gt; 1; //对区间两部分进行排序 merge_sort(q, l ,mid), merge_sort(q, mid+1, r); //进行归并 int k = 0, i = l, j = mid+1; //k：表示tmp数组中已经有多少数了 while(i &lt;= mid &amp;&amp; j &lt;= r) &#123; if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; &#125; while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; //将tmp数组赋值给q数组 for(i=l, j=0; i&lt;=r; i++,j++) q[i] = tmp[j]; &#125; 注解 归并排序要定义一个tmp数组用于存放q数组中已排序的部分，最后再将tmp数组赋给q数组 二分 二分与数据是否具有单调性无关。有单调性必定能进行二分，但无单调性也可以进行二分。 题目的解就是二分的边界 若题目存在无解，在进行二分的过程中不需要考虑无解的情况，也不会存在无解的情况，而是根据二分出来后的边界来判断题目是否无解。 整数二分——模板题 数的范围 bool check(int x) &#123;/* ... */&#125; //检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) &#123; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; //注解2 if(check(mid)) r = mid; else l = mid + 1; &#125; return l; //返回边界l或r &#125; // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) &#123; while(l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; //注解2,3 if(check(mid)) l = mid; else r = mid -1; &#125; return l; //返回边界l或r &#125; 注解 整数二分完后 l = r 整数二分有两个模板，适用于两种情况；具体判断方法如下： 首先都假设 mid = l + r &gt;&gt; 1; 接着判断是 r = mid 还是 l = mid; 如果是前者，则 mid = l + r &gt;&gt; 1; 如果是后者，则 mid = l + r + 1 &gt;&gt;1; 为啥 l = mid 时 mid = l + r + 1 &gt;&gt; 1而不是 l + r &gt;&gt; 1? 假设： l = mid， mid = l + r &gt;&gt;1； 原因：当 l = r-1 时，mid = l + r &gt;&gt; 1 = l; 当check(mid)为true时， l = mid;执行的区间是[mid,r] = [l, r]，和上一个区间相同，从而导致死循环。 浮点数二分——模板题 数的三次方根 bool check(int x) &#123;/* ... */&#125; //检查x是否满足某种性质 double bsearch_3(double l, double r) &#123; const double eps = 1e-8; //eps表示精度，取决于题目对精度的要求 while(r - l &gt; eps) &#123; double mid = (l + r) / 2; //注解2 if(check(x)) r = mid; else l = mid; &#125; return l; //返回边界l或r &#125; 注解 浮点数二分不需要像整数二分考虑边界问题，只需要根据精度来确定 mid = l + r &gt;&gt; 1的位运算符&quot;&gt;&gt;&quot;只适用于int型，当为double型时，mid = (l + r) / 2; 高精度 大整数的存储：用vector数组存储，第0位对应大数的个位，以此类推。好处：方便最高位进位 A &lt; 10 和 len(A) &lt; 10的区别: 前者表示Ａ在[0,9]中任取一个数，后者表示Ａ在[0，999999999]中任取一个数 高精度运算：A + B , A - B , A * b , A / b中，各数的范围如下： b &lt; 106, len(A) &lt; 106, len(B) &lt; 106, 高精度运算的思想: 大整数的存储 模拟人工的加减乘除运算 高精度加法——模板题 高精度加法 思路 大整数的存储：vector数组第0位存储A的个位… C = A + B，保证 len(A) &gt; len(B), A &gt;= 0, B &gt;= 0 如果 len(A) &lt; len(B)，则 C = B + A；反之，直接相加 对于每一位的加法运算：C[i] = A[i] + B[i] + t， t = C[i] / 10 代码 // C = A + B, A &gt;= 0, B &gt;= 0 vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123; if(A.size() &lt; B.size()) return add(B,A); vector&lt;int&gt; C; int t = 0; //上一位的进位 for(int i=0; i&lt;A.size(); i++) &#123; t += A[i]; if(i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if(t) t.push_back(t); return C; &#125; 高精度减法运算——模板题 高精度减法 思路 大整数的存储：vector数组第0位存储A的个位… C = A - B ：要保证A &gt;= B, A &gt;= 0, B &gt;= 0 如果A - B &lt; 0，则 A - B = - (B - A)；反之直接相减 对于每一位的减法运算：C[i] = A[i] - B[i] - t，t = 0 || 1 如果C[i]小于0，则借位；反之不借 代码 // C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0 vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123; vector&lt;int&gt; C; int t = 0; //上一位的借位 for (int i = 0; i &lt; A.size(); i ++ ) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); //注解1 if (t &lt; 0) //注解2 t = 1; else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) //注解3 C.pop_back(); return C; &#125; 注解 (t + 10) % 10包含了：t&lt;0借位 和 t&gt;0不借位两种情况 t &lt; 0 代表有借位 t = 1，否则无借位 t = 0 while(C.size() &gt; 1 &amp;&amp; C.back() == 0) 是为了去掉前置0（103 - 100 = 003–&gt;3，100 - 100 = 000–&gt;0） 高精度乘低精度——模板题 高精度乘法 思路 大整数的存储：vector数组第0位存储A的个位… C = A * b, 保证 A &gt;= 0, b &gt; 0 对于每一位的乘法运算：C[i] = (A[i] * b + t) % 10， t = C[i] / 10 这里是将b整体看成乘数，而不是b中的每一位 代码 // C = A * b, A &gt;= 0, b &gt; 0 vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b) &#123; vector&lt;int&gt; C; int t = 0; for(int i=0; i &lt; A.size() || t; i++) //注解1 &#123; if(i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); //注解2 return C; &#125; 注解 i &lt; A.size() || t ：表示只有处理完A的每一位乘法，并且没有进位时就结束循环 如果for条件是i &lt; A.size()，那么当A的最后一位是2，b是1000，处理完2 * 1000 = 2000就会结束for循环，还需另写一个while()循环处理剩余的进位(2000) 去掉前置0 （12345 * 0 = 00000–&gt; 0） 高精度除以低精度——模板题 高精度除法 思路 大整数的存储：vector数组第0位存储A的个位… C = A / b, 保证 A &gt;= 0, b &gt; 0 对于每一位的除法运算：C[i] = (r * 10 + A[i]) / b， r = (r * 10 + A[i]) % b r：上一位的余数 代码 // A / b = C ... r, A &gt;= 0, b &gt; 0 vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) //r是引用 &#123; vector&lt;int&gt; C; //商 r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) //注解1 &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); //注解2 while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); //注解3 return C; &#125; 注解 除法是从A.size()-1开始for循环，和其他三种运算不同。这是因为除法是从数的高位开始相除，而其他三种运算是从数的个位开始运算 因为vector数组是低位存数的个位，而除法的for循环里vector存放的是数的高位，所以要翻转 去掉前导0（1000 / 9 = 0111 --&gt; 111) 前缀和与差分 一维前缀和——模板题 前缀和 定义：s[i] = a[1] + a[2] + a[3] + … + a[i] 公式：前提条件：s[0] = 0，且从s[1]开始 求前缀和：s[i] = s[i-1] + a[i] 子区间和：a[l...r] = s[r] - s[l-1] 二维前缀和——模板题 子矩阵的和 定义：s[i,j] = 第i行j列格子左上部分所有元素的和 公式： 求前缀和： s[i,j] = s[i,j-1] + s[i-1,j] - s[i-1,j-1] + a[i,j] 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：s[x2,y2] - s[x1 - 1,y2] - s[x2,y1 - 1] + s[x1 - 1,y1 - 1] 一维差分——模板题 差分 定义：对于a数组，求一个b数组使得a[i] = b[1] + b[2] + … + b[i] (即a是b数组的前缀和)，则称b是a数组的差分 公式：前提条件：a[0] = 0，且从a[1]开始赋值 求差分：b[i] = a[i] - a[i-1] 给数组a的区间[l, r]中的每个数加上c：b[l] += c, b[r + 1] -= c 说明： 因为a[i] = b[1] + b[2] + … + b[i]，所以： b[l] += c：会导致a[l], a[l+1], a[l+2] … a[n]都会加上c b[r+1] -=c：会导致a[r+1], a[r+2], a[r+3]… a[n]都会减少一个c 两个语句最后使得：a[l], a[l+1], a[l+2] … a[r] 中的每一个数都加上c 求差分b数组的另一种方法：插入方法（该方法也适用于求二维差分） 若a[1] = 1, a[2] = 3, a[3] = 8，即相当于对 [1,1] + 1, [2,2] + 3, [3,3] + 8…进行插入操作就可求出b数组 该方法前提是：a数组初始定义时值为0 二维差分——模板题 差分矩阵 公式： 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： s[x1, y1] += c, s[x2 + 1, y1] -= c, s[x1, y2 + 1] -= c, s[x2 + 1, y2 + 1] += c 说明：利用一维差分中的插入方法求b数组 双指针算法——模板题 最长连续不重复子序列, 数组元素的目标和 //朴素算法： for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; //具体问题逻辑 &#125; &#125; //双指针算法 for (int i = 0, j = 0; i &lt; n; i ++ ) &#123; while (j &lt; i &amp;&amp; check(j, i )) j ++ ; // 具体问题的逻辑 &#125; 注解： 这里 j &lt; i的，即j在i的左边 双指针核心思想： 双指针算法将O(N^2)的算法优化成 O(N)，因为while()循环里的j只会遍历一次; 双指针常见问题分类： （1）对于一个序列，用两个指针维护一段区间（例子：快速排序） （2）对于两个序列，两个指针各自指向一个序列，维护某种次序（例子：归并排序） 位运算——模板题 二进制中1的个数 求n的二进制中第k位数字: n &gt;&gt; k &amp; 1 (k代表第k个位置，从0开始) 返回n的二进制数中最后一位1：lowbit(n) = n &amp; -n lowbit基本应用：求n的二进制数中1的个数 注解： n = 10 = (1010)2，k = 2 n&gt;&gt;k&amp;1 = 0 (k从0开始算) lowbit(10) = lowbit((1010)2) = (10)2 lowbit(40) = lowbit((101000)2) = (1000)2 lowbit的推理 n = (1010…10…00)2 [-n]补 = (0101…10…00) 2 lowbit(n) = n &amp; -n = n &amp; [n]补 = (0000…10…00)2 = (10…00)2 离散化——模板题 区间和 基本应用 a数组中有0~105个元素，每个元素的值为0~109，而有时候我们要用到它的值作为一个数组的下标 假如：int a[] = {1,20,300,40000,50000000}; 数组b要用到数(50000000)的下标，但不可能定义b[50000000]，因此我们要将a数组中的值一一映射。 vector&lt;int&gt; alls; // 存储所有待离散化的值 // 注解1：去掉重复元素 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 &#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1; // 注解2：从1开始映射： 1, 2, ... n &#125; 注解 离散化需要去重 return r + 1; 表示从1开始映射 return r; 表示从0开始映射","categories":[{"name":"技术","slug":"技术","permalink":"https://sunwarm2001.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://sunwarm2001.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"https://sunwarm2001.github.io/tags/%E6%A8%A1%E6%9D%BF/"}],"author":"sunwarm"},{"title":"BFS模板","slug":"BFS模板","date":"2020-11-05T15:10:48.000Z","updated":"2022-08-26T08:36:45.154Z","comments":true,"path":"2020/11/05/BFS模板/","link":"","permalink":"https://sunwarm2001.github.io/2020/11/05/BFS%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"BFS 模板 解决问题：最优解问题，如最短路径 BFS 思路：队列 queue 初始化队列Q Q=&#123;起点s&#125; 标记起点s已被访问 while (Q非空) &#123; 取出Q队首元素u，同时把u弹出队列。 if（u==目标状态） &#123;.......&#125; 求出所有与u相邻元素v &#123; if(v满足条件且未被访问) &#123; v入队列，标记v已被访问 &#125; &#125; &#125; 题目： 走迷宫：给定一个 N*M 方格的迷宫，其中.代表可通过，*代表障碍物。问: 每个方格最多经过 1 次，有多少种从左上角到右下角的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。 #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int map[105][105]; //定义地图 bool vis[105][105]; //判断某点是否走过 //定义上&#123;-1,0&#125;、下&#123;1,0&#125;、左&#123;0,-1&#125;、右&#123;0,1&#125;四个方向 //注：因为地图是数组来创建的，当往上走时是行-1，列不变，因此为&#123;-1,0&#125;。而不是坐标系中的&#123;0,-1&#125; int dir[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;; int n, m; //定义图上的坐标点 class Node &#123; public: int x, y, d; //x：行 y：列 d:走过的长度 Node(int a,int b,int c):x(a),y(b),d(c)&#123;&#125; &#125;; //检查坐标是否在地图中 bool check(int i, int j) &#123; if (i &gt; 0 &amp;&amp; i &lt;= n &amp;&amp; j &gt; 0 &amp;&amp; j &lt;= m) return true; else return false; &#125; void bfs() &#123; queue&lt;Node&gt; p; p.push(Node(1, 1, 0)); //起点（1,1） vis[1][1] = true; //表示起点（1,1）已被走过 while (!p.empty()) &#123; Node next = p.front(); p.pop(); if (next.x == n &amp;&amp; next.y == m) //当取出的是终点时，则输出走过的长度 &#123; cout &lt;&lt; next.d; return; &#125; for (int i = 0; i &lt; 4; i++) //将该点上下左右四个方向都走一遍 &#123; int dx = next.x + dir[i][0]; int dy = next.y + dir[i][1]; if (check(dx, dy) &amp;&amp; map[dx][dy] == 0 &amp;&amp; vis[dx][dy] == false) &#123; vis[dx][dy] = true; p.push(Node(dx, dy, next.d + 1)); &#125; &#125; &#125; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; map[i][j]; bfs(); return 0; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://sunwarm2001.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://sunwarm2001.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"https://sunwarm2001.github.io/tags/%E6%A8%A1%E6%9D%BF/"}],"author":"sunwarm"},{"title":"DFS模板","slug":"DFS模板","date":"2020-11-05T15:10:43.000Z","updated":"2022-08-25T08:17:57.276Z","comments":true,"path":"2020/11/05/DFS模板/","link":"","permalink":"https://sunwarm2001.github.io/2020/11/05/DFS%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"DFS模板 解决问题：所有解问题，或连通性问题 DFS思路：递归 void dfs(int step) &#123; 判断边界if() &#123; 相应操作 &#125; 尝试每一种可能for() &#123; 满足条件if() 标记 == true; 继续下一步:dfs(step + 1) 恢复初始状态（回溯的时候要用到） &#125; &#125; 题目 全排列：输出自然数 1 到 n 所有不重复的排列，即 n 的全排列，要求所产生的任一数字序列中不允许出现重复的数字 递归实现 #include&lt;iostream&gt; using namespace std; const int N = 10; int num[N],n; bool vis[N]; void dfs(int u) &#123; if (u &gt; n) &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; num[i] &lt;&lt; ' '; cout &lt;&lt; endl; return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; num[u] = i; vis[i] = true; dfs(u + 1); vis[i] = false; &#125; &#125; return; &#125; int main() &#123; cin &gt;&gt; n; dfs(1); return 0; &#125; 借助STL的next_permutation(arr, arr + size)来实现; //STL中的next_permutation(arr, arr + size); #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int main() &#123; int n; vector&lt;int&gt; v; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) v.push_back(i); //若用while()语句则直接执行next_permutation（）函数，会少初始情况 do &#123; for(auto x:v) cout&lt;&lt;x&lt;&lt;' '; cout&lt;&lt;endl; &#125;while(next_permutation(v.begin(),v.end())); //记得有分号 return 0; &#125; n皇后问题：在一个N*N的棋盘上放置N个皇后，使这N个皇后不能在同一行、同一列、同一斜线上。 #include&lt;iostream&gt; using namespace std; int n; const int Max = 100; //注意把数组开大：因为后面有b[row-j+n]，不开大可能超出数组范围。 bool col[Max], a[Max], b[Max]; //col：列，a：斜线，b：斜线 char re[Max][Max]; void dfs(int row) &#123; if (row == n) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; re[j]&lt;&lt;endl; cout &lt;&lt; endl; return; &#125; for (int j = 0; j &lt; n; j++) &#123; if (!col[j] &amp;&amp; !a[row + j] &amp;&amp; !b[row-j + n]) //b[row-j+n]加了n之后，row-j+n和j-row+n效果一样 &#123; re[row][j] = 'Q'; col[j] = a[row + j] = b[row-j + n] = true; dfs(row + 1); col[j] = a[row + j] = b[row-j + n] = false; re[row][j] = '.'; //别忘记复原 &#125; &#125; return; &#125; int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) re[i][j] = '.'; dfs(0); return 0; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://sunwarm2001.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://sunwarm2001.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"https://sunwarm2001.github.io/tags/%E6%A8%A1%E6%9D%BF/"}],"author":"sunwarm"},{"title":"markdown语法","slug":"markdown语法","date":"2020-11-05T15:10:43.000Z","updated":"2022-08-25T10:23:00.039Z","comments":true,"path":"2020/11/05/markdown语法/","link":"","permalink":"https://sunwarm2001.github.io/2020/11/05/markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"markdown语法 一. 标题 语法： ‘#’ 标记1-6级标题，一级标题对应一个’#’，以此类推 用法： ‘#’ 后必须加个空格 例子： # 一级标题 ## 二级标题 ### 三级标题 ....... 效果如下： 一级标题 二级标题 三级标题 二. 空格和换行 1. 空格 markdown的空格有两种方法： 手动输入(&amp;nbsp;) 使用全角空格(shift+空格) 2. 换行 markdown的换行有三种方法 在尾部使用两个空格 + 回车 使用标签&lt;br&gt; 使用两下回车 （ 此方法会多空一行） 三. 字体 1.加粗：文字用 ‘**’ 包起来 2.斜体：文字用’*'包起来 3.斜体加粗：文字用’***'包起来 4.删除线：文字用’~~'包起来 例子： **加粗的文字** *斜体的文字* ***斜体加粗的文字*** ~~加删除线的文字~~ 效果如下： 加粗的文字 斜体的文字 斜体加粗的文字 加删除线的文字 四. 分隔线、下划线、引用 1. 分隔线：使用三个或以上的 减号(-)、星号(*)、底线(_) 2.下划线：通过&lt;u&gt;标签实现 例子：&lt;u&gt;文字&lt;/u&gt; 效果：文字 3.引用：在引用的文字前加 &gt; 注：引用可以嵌套，如加多个 &gt; 例子：&gt;引用1 &gt;&gt;引用2 &gt;&gt;&gt;引用3 效果： 引用1 引用2 引用3 五. 列表 1. 无序列表 用法：使用星号(*)、加号(+)、减号(-)中的任一个作为列表标记，空一格在填写内容 例子： - one - two - three 2. 有序列表 用法：数字加上.并空一格在填写内容 例子： 1. 列表one 2. 列表two 3. 列表three 3. 列表嵌套 在下一级前使用tab键（或者空三个） 例子： 1. The first - The first of one - The first of two 2. The second - The second of one - The second of two - 无序1 - 无序1.1 - 无序1.1.1 效果： The first The first of one The first of two The second The second of one The second of two 无序1 无序1.1 无序1.1.1 六. 代码块 1. 单行代码 用法：用一个反引号(`)包起来 例子 `printf()` 效果 printf() 2. 代码块 用法：两边用三个反引号包起来，并且每边都独占一行 例子： ``` 代码1… 代码2… 代码3… ``` 效果 代码1... 代码2... 代码3... 七. 链接 用法： [标题](“超链接地址”) &lt;链接地址&gt; 例子： [百度](https://www.baidu.com) [简书](https://www.jianshu.com) &lt;https://www.taobao.com&gt; 百度 简书 https://www.taobao.com 八. 图片 用法：![alt](图片地址 “title”) 开头是一个感叹号(!) alt：显示在图片下面的文字，相当于对图片内容的解释。 title：图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 例子 ![冰冻柠檬](https://cdn.jsdelivr.net/gh/sunwarm2001/cdn@1.1/img/myown/10.jpg) 效果","categories":[{"name":"技术","slug":"技术","permalink":"https://sunwarm2001.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://sunwarm2001.github.io/tags/%E9%98%85%E8%AF%BB/"},{"name":"markdown","slug":"markdown","permalink":"https://sunwarm2001.github.io/tags/markdown/"}],"author":"sunwarm"},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2022-08-25T10:23:17.734Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://sunwarm2001.github.io/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中… 交流群 若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者 如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程 那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装 hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置 博客根目录下的_config配置 站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置 其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: &#123; path: /, fa: fa-fort-awesome faa-shake &#125; 归档: &#123; path: /archives, fa: fa-archive faa-shake, submenus: &#123; 技术: &#123;path: /categories/技术/, fa: fa-code &#125;, 生活: &#123;path: /categories/生活/, fa: fa-file-text-o &#125;, 资源: &#123;path: /categories/资源/, fa: fa-cloud-download &#125;, 随想: &#123;path: /categories/随想/, fa: fa-commenting-o &#125;, 转载: &#123;path: /categories/转载/, fa: fa-book &#125; &#125; &#125; 清单: &#123; path: javascript:;, fa: fa-list-ul faa-vertical, submenus: &#123; 书单: &#123;path: /tags/悦读/, fa: fa-th-list faa-bounce &#125;, 番组: &#123;path: /bangumi/, fa: fa-film faa-vertical &#125;, 歌单: &#123;path: /music/, fa: fa-headphones &#125;, 图集: &#123;path: /tags/图集/, fa: fa-photo &#125; &#125; &#125; 留言板: &#123; path: /comment/, fa: fa-pencil-square-o faa-tada &#125; 友人帐: &#123; path: /links/, fa: fa-link faa-shake &#125; 赞赏: &#123; path: /donate/, fa: fa-heart faa-pulse &#125; 关于: &#123; path: /, fa: fa-leaf faa-wrench , submenus: &#123; 我？: &#123;path: /about/, fa: fa-meetup&#125;, 主题: &#123;path: /theme-sakura/, fa: iconfont icon-sakura &#125;, Lab: &#123;path: /lab/, fa: fa-cogs &#125;, &#125; &#125; 客户端: &#123; path: /client/, fa: fa-android faa-vertical &#125; RSS: &#123; path: /atom.xml, fa: fa-rss faa-pulse &#125; # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - &#123;url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png&#125; - &#123;url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg&#125; - &#123;url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg&#125; # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: &#123;url: http://github.com/honjun, img: /img/social/github.png&#125; sina: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png&#125; wangyiyun: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png&#125; zhihu: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png&#125; email: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg&#125; wechat: &#123;url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png&#125; # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: &#123;url: http://github.com/honjun, fa: fa-github, color: 333&#125; weibo: &#123;url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39&#125; qq: &#123;url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe&#125; # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置 分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置 如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置 番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置 主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： &#123;% bili video_id [page] %&#125; 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： &#123;% fb_img src [caption] %&#125; 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来… To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://sunwarm2001.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://sunwarm2001.github.io/tags/web/"},{"name":"阅读","slug":"阅读","permalink":"https://sunwarm2001.github.io/tags/%E9%98%85%E8%AF%BB/"}],"author":"hojun"}],"categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://sunwarm2001.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"阅读","slug":"阅读","permalink":"https://sunwarm2001.github.io/categories/%E9%98%85%E8%AF%BB/"},{"name":"技术","slug":"技术","permalink":"https://sunwarm2001.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"插件配置","slug":"插件配置","permalink":"https://sunwarm2001.github.io/categories/%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"git","slug":"git","permalink":"https://sunwarm2001.github.io/tags/git/"},{"name":"pytorch","slug":"pytorch","permalink":"https://sunwarm2001.github.io/tags/pytorch/"},{"name":"服务器","slug":"服务器","permalink":"https://sunwarm2001.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"IDM","slug":"IDM","permalink":"https://sunwarm2001.github.io/tags/IDM/"},{"name":"小妙招","slug":"小妙招","permalink":"https://sunwarm2001.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"},{"name":"python","slug":"python","permalink":"https://sunwarm2001.github.io/tags/python/"},{"name":"vscode","slug":"vscode","permalink":"https://sunwarm2001.github.io/tags/vscode/"},{"name":"插件","slug":"插件","permalink":"https://sunwarm2001.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"阅读","slug":"阅读","permalink":"https://sunwarm2001.github.io/tags/%E9%98%85%E8%AF%BB/"},{"name":"c盘","slug":"c盘","permalink":"https://sunwarm2001.github.io/tags/c%E7%9B%98/"},{"name":"hexo","slug":"hexo","permalink":"https://sunwarm2001.github.io/tags/hexo/"},{"name":"typora","slug":"typora","permalink":"https://sunwarm2001.github.io/tags/typora/"},{"name":"图床","slug":"图床","permalink":"https://sunwarm2001.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"美化","slug":"美化","permalink":"https://sunwarm2001.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"latex","slug":"latex","permalink":"https://sunwarm2001.github.io/tags/latex/"},{"name":"算法","slug":"算法","permalink":"https://sunwarm2001.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"https://sunwarm2001.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"markdown","slug":"markdown","permalink":"https://sunwarm2001.github.io/tags/markdown/"},{"name":"web","slug":"web","permalink":"https://sunwarm2001.github.io/tags/web/"}]}